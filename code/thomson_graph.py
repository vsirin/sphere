# -*- coding: utf-8 -*-
"""Thomson_graph.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UidZu9iDUXQuHtm8x7p7eB-l3djVT-g3

# Import
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install stripy
# !pip install python-intervals
# !pip install lavavu
# 
# 
# ## get package then extract
# #!wget https://anaconda.org/conda-forge/cartopy/0.16.0/download/linux-64/cartopy-0.16.0-py36h81b52dc_2.tar.bz2
# #!tar xvjf cartopy-0.16.0-py36h81b52dc_2.tar.bz2
# #!cp -r lib/python3.6/site-packages/* /usr/local/lib/python3.6/dist-packages/
# ## install dependencies
# #!pip install shapely pyshp
# #!apt install libproj-dev libgeos-dev
# ## finally
# #import cartopy
# #import cartopy.crs as ccrs
# 
# import os, glob
# from zipfile import ZipFile
# import networkx as nx
# import matplotlib.pyplot as plt
# from matplotlib import colors
# from mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollection
# import scipy.optimize as opt
# from scipy.spatial import Delaunay
# from scipy.spatial import SphericalVoronoi
# from mpl_toolkits.mplot3d import proj3d
# from google.colab import files
# import numpy, scipy
# import numpy as np
# import scipy as sp
# from numpy.linalg import norm
# from numpy import pi
# import math
# from math import acos
# import gdal
# import itertools
# import json
# import stripy
# import intervals as I
# import lavavu

from google.colab import files
!rm -r thomson
files.upload()
!unzip thomson.zip

"""# Util"""

def spherical2cart(lat, lon):
    return np.array([np.cos(lat) * np.cos(lon), np.cos(lat) * np.sin(lon), np.sin(lat)])  
def cart2spherical(x):
    return np.array([np.arcsin(x[2]), np.arctan2(x[1], x[0])])

def connect_dist2(g):
    g1 = nx.convert_node_labels_to_integers(g)
    n = g.number_of_nodes()
    to_connect = []
    for i in range(n):
        for j in range(i+1,n):
            if nx.shortest_path_length(g1,i,j)==2:
                to_connect.append([i,j])
    for e in to_connect:
        g1.add_edge(e[0], e[1])            
    return g1    
            

def write_dimacs(g, filename):
    g1 = nx.convert_node_labels_to_integers(g, first_label=1)
    f = open(filename, 'w')
    f.write('p edges ' + str(g.number_of_nodes()) + ' ' + str(g.number_of_edges()) + '\n')
    for e in g1.edges():
        f.write('e ' + str(e[0]) + ' ' + str(e[1]) + '\n')
    f.close()

def read_dimacs_graph(file = 'graph.col'):
     
    if not (os.path.exists(file) and os.path.getsize(file) > 0):        
        raise Exception("File " + file + " not found")
        
    nodes = []    
    edges = []
    labels = []
    got_labels = False
    nnodes = nedges = 0
        
    with open(file, 'r') as f:
        for line in f:
            line = [l.strip() for l in line.split(' ')]
            if line[0] == 'c': #comment
                continue
            elif line[0] == 'p': #problem
                nnodes = int(line[2])
                nedges = int(line[3])
                nodes = list(range(1, nnodes + 1))
                labels = [0] * nnodes
            elif line[0] == 'e': #edge
                edges.append((int(line[1]), int(line[2])))
            elif line[0] == 'l':
                labels[int(line[1]) - 1] = int(line[2])
                got_labels = True

    if got_labels:        
        nodes = [(n, {'c' : l}) for n, l in zip(nodes, labels)]

    g = nx.Graph()
    g.add_nodes_from(nodes)
    g.add_edges_from(edges)
    return g

# чтение из файла для Cambrigde Cluster Database
def read_points2(filename):
    points = []
    f = open(filename, 'r')
    k = int(f.readline())
    f.readline()
    for s in f:
        l = s.split(' ')        
        points.append(np.array([float(l[1]), float(l[2]), float(l[3])], dtype=np.float64))
    f.close()
    return np.array(points)

def dist(u, v):    
    return norm(u - v)

# угол между радиус-векторами
def angle(p1 ,p2):    
    c = np.dot(p1, p2) / norm(p1) / norm(p2)
    return np.arccos(np.clip(c, -1, 1))
    
# середина дуги между x, y
def middle(x, y):    
    z = (x + y) / 2
    return z / norm(z)

# диаметр области
def get_diam(faces): 
    diam = 0.0
    for f in faces:
        ij = itertools.combinations(range(len(f)), 2)
        dists = np.array([dist(f[i], f[j]) for i, j in ij])
        diam = np.max([diam, np.max(dists)])
    return diam
    
# расстояние между областями (старое)
#def faces_dist(face1, face2):
#    distances = np.array([dist(u, v) for u, v in itertools.product(face1, face2)])    
#    return np.min([np.min(distances), 2.0])

# 'центр описанной окружности' сферического треугольника, вершина диаграммы Вороного
def center(x, y, z):
    c = np.vstack([x, y, z])
    x0 = np.mean(c, axis=0)
    x0 = x0 / norm(x0)
    f = lambda v: np.square(np.dot(v, x - y)) + np.square(np.dot(v, x - z)) + np.square(np.dot(v, v) - 1)    
    sol = opt.minimize(f, x0, method='nelder-mead')
    return sol.x

def plane_equation(x,y,z):
    a1 = x[1] - x[0] 
    b1 = y[1] - y[0] 
    c1 = z[1] - z[0] 
    a2 = x[2] - x[0] 
    b2 = y[2] - y[0] 
    c2 = z[2] - z[0] 
    a = b1 * c2 - b2 * c1 
    b = a2 * c1 - a1 * c2 
    c = a1 * b2 - b1 * a2 
    d = (- a * x[0] - b * y[0] - c * z[0]) 
    return [a, b, c, d]

def foot(x,y,z,v):
    p = plane_equation(x,y,z)    
    n = [p[0],p[1],p[2]]
    l = norm(n)
    n = [n[0]/l,n[1]/l,n[2]/l]
    h = p[0]*v[0]+p[1]*v[1]+p[2]*v[2]+p[3]
    n1 = [n[0]*h/l,n[1]*h/l,n[2]*h/l]
    return [v[0]-n1[0],v[1]-n1[1],v[2]-n1[2]]

def circ_dist(x,y,v,eps=1E-8):
    z = [0.0,0.0,0.0]
    f = foot(x,y,z,v)
    
    l = norm(f)
    f = [f[0]/l,f[1]/l,f[2]/l]
    a1 = angle(x,f)
    a2 = angle(f,y)
    a3 = angle(x,y)
    d = min(dist(x,v),dist(y,v))    
    if abs(a1+a2-a3)<eps:
        d = min(d,dist(f,v))
    return d    
        
# расстояние между областями
def faces_dist(face1, face2):
    f1 = face1
    f2 = face2
    d = 2.0
    for i in range(len(f1)):        
        for j in range(len(f2)):
            v = f1[i]
            x = f2[j]
            if j==len(f2)-1:
                y = f2[0]
            else:
                y = f2[j+1]
            d = min(d,circ_dist(x,y,v))    
    for i in range(len(f2)):
        for j in range(len(f1)):
            v = f2[i]
            x = f1[j]
            if j==len(f1)-1:
                y = f1[0]
            else:
                y = f1[j+1]
            d = min(d,circ_dist(x,y,v))    
    return d

"""#Build graphs & faces"""

# есть ребро, если angle_min < a < angle_max
def get_graph(points, angle_min, angle_max):   
    g = nx.Graph()
    n = len(points)
    for i in range(n):
        for j in range(i + 1, n):            
            if angle_min < angle(points[i], points[j]) < angle_max:
                g.add_edge(i, j)
    return g

def get_graph2(points, angle_min, angle_max):
    g = nx.Graph()
    
    points_spherical = np.array(list(map(cart2spherical, points)))
    vertices_lat = points_spherical.T[0]
    vertices_lon = points_spherical.T[1]
    spherical_triangulation = stripy.sTriangulation(lons=vertices_lon, lats=vertices_lat)
    
    for tri in spherical_triangulation.simplices:
        g.add_nodes_from(itertools.combinations(tri, 2))
        
    return g

def get_dual2(g, points):
    sv = SphericalVoronoi(points)
    sv.sort_vertices_of_regions()
    faces = []
    for region in sv.regions:
        face = sv.vertices[region]
        faces.append(face)
    return np.array(faces)

# область диаграммы, соотв. вершине триангуляции
def get_dual(g, points):
    faces = []
    for v in range(g.number_of_nodes()):
        neigh = g.neighbors(v)
        
        try: 
            n_cyc = nx.cycle_basis(g.subgraph(neigh))[0]   # цикл на соседних вершинах
            n_cyc.append(n_cyc[0])
        except IndexError:
            pass
            #print(nx.cycle_basis(g.subgraph(neigh)))
        
        face = []   # вершины области
        for i in range(len(n_cyc) - 1):
            c = center(points[v], points[n_cyc[i]], points[n_cyc[i+1]])
            face.append(c)
            
        faces.append(face)
    return faces
        

# минимум из расстояний между областями на расстоянии >3
def faces_d3_dist(g, faces):
    n = g.number_of_nodes()
    d = 2.0
    for i in range(n):
        for j in range(i + 1, n):
            if nx.shortest_path_length(g, i, j) == 3:                
                d = np.min([d, faces_dist(faces[i], faces[j])])
    return d

"""# Intervals"""

wiki_table = json.load(open('thomson/thomson/wiki_table.txt'))
thomsons = [f.strip() for f in open('thomson/thomson/list_of_files.txt')]
thomsons.sort(key=lambda x: int(x.replace('.xyz', '')))

interv1 = []
interv2 = []
filess = []

for thomson in thomsons:
    try:        
        good = True
        N = thomson.replace('.xyz', '')    
        for i in ['v3', 'v4', 'v7', 'v8', 'f4']:
            if wiki_table[N][i] != 0:
                good = False
                break
        if wiki_table[N]['theta2'] == 0:
            good = False

        if not good:
            continue
        
        angle_min = np.radians(wiki_table[N]['theta'])
        angle_max = np.radians(wiki_table[N]['theta2'])
        
        found = False
        
        points = read_points2('thomson/thomson/' + thomson)
        g = get_graph(points, angle_min, angle_max)            
        if g.number_of_edges() == wiki_table[N]['e']:
            found = True            
            faces = get_dual2(g, points)
            d0 = get_diam(faces)
            d1 = faces_d3_dist(g, faces)
            
            f = 0
            s = 0
            for v,d in g.degree:
                if d == 5:
                    f += 1
                if d == 6:
                    s += 1
            if f != wiki_table[N]['v5'] or s != wiki_table[N]['v6']:
                found = False
                    
        
        if found:                        
            test = int(np.sum(np.array(list(nx.triangles(g).values()))) / 3) - wiki_table[N]['f3']            
            if test == 0:
                print('{} {} {} {} {}'.format(thomson, g.number_of_edges(), d0, d1, d1/d0))
                if d1/d0 > 1:
                    interv1.append((1/d1, 1/d0))
                    write_dimacs(g, thomson + "_d1_our.txt")
                    write_dimacs(connect_dist2(g), thomson + "_d2_our.txt")
                    filess.append(thomson + "_d1_our.txt")
                    filess.append(thomson + "_d2_our.txt")
                
    except Exception as e: 
        pass#print(e)

with ZipFile('my_python_files.zip', 'w') as zzz:
    for file in filess:
        zzz.write(file)

ii = I.empty()
for a, b in interv1:
    ii = ii | I.open(np.round(a, 5), np.round(b, 5))
print(ii)

"""# Test & plot"""

points = read_points2('thomson/thomson/46.xyz')    

angle_min = np.radians(29.0)
angle_max = np.radians(38.0)

g = get_graph(points, angle_min, angle_max)
g2 = read_dimacs_graph('thomson/graphs/our_colored/46.xyz_d2_our.txt_9_colored')
g2 = nx.convert_node_labels_to_integers(g2)

faces = get_dual(g, points)
d0 = get_diam(faces)
d1 = faces_d3_dist(g, faces)

print(int(np.sum(np.array(list(nx.triangles(g).values()))) / 3))
print(g.number_of_edges())
print(len(faces))
print('max_diam =', d0)
print('min_dist =', d1)
print('ratio =', d1/d0)

f = 0
s = 0
for v,d in g.degree:
    if d == 5:
        f += 1
    if d == 6:
        s += 1
print(f, s)

rm /*

fig = plt.figure()
fig.set_size_inches(15, 15)
ax = fig.add_subplot(111, projection='3d')

# plot the unit sphere for reference (optional)
u = np.linspace(0, 2 * np.pi, 100)
v = np.linspace(0, np.pi, 100)
x = np.outer(np.cos(u), np.sin(v))
y = np.outer(np.sin(u), np.sin(v))
z = np.outer(np.ones(np.size(u)), np.cos(v))
ax.plot_surface(x, y, z, color='y', alpha=0.1)

# plot generator points
ax.scatter(points[:, 0], points[:, 1], points[:, 2], c='b')

# indicate Voronoi regions (as Euclidean polygons)
for region in faces:
    random_color = colors.rgb2hex(np.random.rand(3))
    polygon = Poly3DCollection([region], alpha=0.8)
    polygon.set_color(random_color)
    ax.add_collection3d(polygon)
    
for u,v in g.edges():    
    random_color = colors.rgb2hex(np.random.rand(3))
    polygon = Line3DCollection([[points[u], points[v]]], alpha=0.9)
    polygon.set_color(random_color)
    ax.add_collection3d(polygon)

plt.show()