# -*- coding: utf-8 -*-
"""Borsuk.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ko0V4j7Zjp90zt77ASuOv0JBX_FjaeMD

#Import
"""

import math
import numpy as np
from numpy import linalg as LA
import networkx as nx

import matplotlib.pylab as plt

from google.colab import files 
#files.upload() 
#files.download("file.txt")

#https://pysathq.github.io/
#!pip install python-sat
import pysat
from pysat.formula import CNF
from pysat.solvers import *

import os
import random
from zipfile import ZipFile
from tqdm import tqdm_notebook as tqdm
from itertools import combinations, permutations

from google.colab import drive
#drive.mount('/content/gdrive')

out_dir = "/content/gdrive/My Drive/graphs"
if not os.path.exists(out_dir):
    os.makedirs(out_dir)
out_dir += "/"

#https://mat.tepper.cmu.edu/COLOR/instances.html
#!wget -nc https://mat.tepper.cmu.edu/COLOR/instances/games120.col #9
#!wget -nc https://mat.tepper.cmu.edu/COLOR/instances/miles1500.col #73
#!wget -nc https://mat.tepper.cmu.edu/COLOR/instances/le450_5b.col #5
#!wget -nc https://mat.tepper.cmu.edu/COLOR/instances/le450_5c.col #5
#!wget -nc https://mat.tepper.cmu.edu/COLOR/instances/le450_15c.col #15
#!wget -nc http://www.cs.utexas.edu/~marijn/CNP/874.edge #5
#files.upload()

"""# Utils"""

class Utils:
    
    def read_dimacs_graph(file = 'graph.col'):
        
        if not (os.path.exists(file) and os.path.getsize(file) > 0):        
            raise Exception("File " + file + " not found")
        
        nodes = []    
        edges = []
        labels = []
        got_labels = False
        nnodes = nedges = 0
        
        with open(file, 'r') as f:
            for line in f:
                line = [l.strip() for l in line.split(' ')]
                if line[0] == 'c': #comment
                    continue
                elif line[0] == 'p': #problem
                    nnodes = int(line[2])
                    nedges = int(line[3])
                    nodes = list(range(1, nnodes + 1))
                    labels = [0] * nnodes
                elif line[0] == 'e': #edge
                    edges.append((int(line[1]), int(line[2])))
                elif line[0] == 'l':
                    labels[int(line[1]) - 1] = int(line[2])
                    got_labels = True

        if got_labels:        
            nodes = [(n, {'c' : l}) for n, l in zip(nodes, labels)]

        g = nx.Graph()
        g.add_nodes_from(nodes)
        g.add_edges_from(edges)
        return g

    def write_dimacs_graph(file = 'graph.col', g = nx.Graph(), comments = []):
        with open(file, 'w') as f:
            for c in comments:
                f.write("c " + c + "\n")
            f.write("p EDGE {} {}\n".format(g.number_of_nodes(), g.number_of_edges()))
            for u, v in g.edges():
                f.write("e {} {}\n".format(u, v))
            for node in g.nodes():
                if 'c' in g.nodes[node]:
                    f.write("l {} {}\n".format(node, g.nodes[node]['c']))

    def draw_with_colors(g = nx.Graph()):
        color_map = []
        for node in g.nodes():
            if 'c' in g.nodes[node]:
                color_map.append(g.node[node]['c'] * 10)            
        nx.draw(g, pos = nx.spring_layout(g, scale=2), node_color=color_map, with_labels=True, cmap = plt.cm.jet)

    def write_proof(file = "proof.txt", proof = []):
        with open(file, 'w') as f:
            for p in proof:
                f.write("%s\n" % str(p))

    def zip_files(file = "archive.zip", files = []):
        with ZipFile(file, 'w') as archive:
            for f in set(files):                
                if not (os.path.exists(file) and os.path.getsize(file) > 0):        
                    raise Exception("File " + file + " not found")
                archive.write(f)
                
def find_triangle(g = nx.Graph()):
    for a in g:
        for b, c in combinations(g[a], 2):
            if b in g[c]:
                return [a, b, c]
    return []
             
    #return set(frozenset([a, b, c]) for a in g for b, c in combinations(g[a], 2) if b in g[c])


def find_isolates(g = nx.Graph()):
    isolates = []
    for n in g:
        if g.degree(n) == 0:
            isolates.append(n)
    return isolates

"""# SAT"""

class ColMap:
    
    def __init__(self, g = nx.Graph(), ncolors = 40):
        
        self.ncolors = ncolors
        self.cmap = dict()
        self.cunmap = dict()
    
        i = 1
        for node in g.nodes():
            for color in range(1, ncolors + 1):            
                self.cmap[(node, color)] = i
                self.cunmap[i] = (node, color)
                i += 1    

    def enc(self, node, color):
        return self.cmap[(node, color)]

    def dec(self, node_color):
        return self.cunmap[node_color]

class ColSAT:
   
    def __init__(self, g = nx.Graph(), ncolors = 10):
        
        self.ncolors = ncolors
        self.g = g.copy()
        self.cmap = ColMap(g, ncolors)        

    def check_coloring(self):
        for n1, n2 in self.g.edges():
            if 'c' not in self.g.nodes[n1] or 'c' not in self.g.nodes[n2]:
                return False
            if self.g.nodes[n1]['c'] == self.g.nodes[n2]['c']:
                return False
        return True
    
    def apply_model2(self, g = nx.Graph()):
        
        gg = g.copy()
        check = set()

        for var in self.model[self.model > 0]:        
            node, color = self.cmap.dec(var)
            gg.nodes[node]['c'] = color
            if (node, color) in check:
                raise Exception("Two colors for one node???")
            else:
                check.add((node, color))

        for n1, n2 in gg.edges():
            if 'c' not in gg.nodes[n1] or 'c' not in gg.nodes[n2]:
                raise Exception("No color")
            if gg.nodes[n1]['c'] == gg.nodes[n2]['c']:
                raise Exception("Bad coloring")
        
        return gg

    def apply_model(self):
        
        check = set()
        for var in self.model[self.model > 0]:        
            node, color = self.cmap.dec(var)
            self.g.nodes[node]['c'] = color
            if (node, color) in check:
                raise Exception("Two colors for one node???")
            else:
                check.add((node, color))
        
        self.colored = self.check_coloring()
        
        if self.colored != self.solved:
            raise Exception("Something went wrong!")
        
        return self.colored
        
    def build_cnf(self):
        
        self.formula = CNF()
        colors = list(range(1, self.ncolors + 1))    

        for n1, n2 in self.g.edges():
            for c in colors:            
                self.formula.append([-self.cmap.enc(n1, c), -self.cmap.enc(n2, c)])

        for n in self.g.nodes():
            self.formula.append([self.cmap.enc(n, c) for c in colors])
            for c1 in colors:
                for c2 in colors:
                    if c1 < c2:
                        self.formula.append([-self.cmap.enc(n, c1), -self.cmap.enc(n, c2)])        
        
        return self.formula
    
    def solve_cnf(self, solver = ''):
        
        #triangle = find_triangle(self.g)
        assumptions = []
        #if len(triangle) > 0:            
        #    assumptions = [self.cmap.enc(triangle[0], 1), self.cmap.enc(triangle[1], 2), self.cmap.enc(triangle[2], 3)]
            
        #Glucose3, Glucose4, Lingeling, MapleChrono, MapleCM, Maplesat, Minisat22, MinisatGH
        #with Glucose4(bootstrap_with=self.formula.clauses, with_proof=True) as ms:        
        
        #for v, d in g2.degree:
        #    if d == 5:
        #        for i in range(5):
        #            assumptions.append(self.cmap.enc(list(g.neighbors(v))[i], i+1))
        #        assumptions.append(self.cmap.enc(v, i+2))
        #        break
        
        with Glucose4(bootstrap_with=self.formula.clauses) as ms:
            ms.conf_budget(1000000)
            ms.prop_budget(100000000)
            self.solved = ms.solve_limited(assumptions=assumptions)
            if self.solved:
                self.model = np.array(ms.get_model())
                self.apply_model()
            else:
                if self.solved is None:
                    pass #print('interrupted')
                self.solved = False
                self.proof = []#ms.get_proof()
                self.colored = False
                
        return self.solved

"""# Main"""

files = [l.split() for l in open('/content/drive/My Drive/graphs/diams.txt')]
files.sort(key = lambda x: int(x[0].replace('.xyz', '')))

ncolors = 9

c7 = set(['12', '14'])
c8 = set(['15', '16', '23', '28', '29', '30', '32', '111', '122', '136', '195'])

for task in tqdm(files):
    
    task_file = task[0].replace('.xyz', '')

    d0 = float(task[1])
    d1 = float(task[2])

    if (d1/d0 > 1) and (task_file not in c7) and (task_file not in c8):
    
        g = Utils.read_dimacs_graph('/content/drive/My Drive/graphs/g/' + task_file + '.g')
        g2 = Utils.read_dimacs_graph('/content/drive/My Drive/graphs/g2/' + task_file + '.g2')

        problem = do_coloring(g2, ncolors)
        
        if problem.solved:
            print(task[0] + ' ' + str(ncolors), 1/d1, 1/d0)
            gg = problem.apply_model2(g)            
            Utils.write_dimacs_graph('/content/drive/My Drive/graphs/colored/' + task_file + '.' + str(ncolors) + 'c', gg)

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

os.path.exists('/content/drive/My Drive/graphs/g2/282.g2')

import glob
import os

#!mkdir '/content/drive/My Drive/graphs/colored'
#ncolors = 8


def do_coloring(g2 = nx.Graph(), ncolors = 10):
    
    problem = ColSAT(g2, ncolors)
    
    problem.build_cnf()
    problem.solve_cnf()    
    
    return problem


out_dir = '/content/gdrive/My Drive/graphs/colored/'
files = []
fffs = set(list(glob.glob("/content/gdrive/My Drive/graphs/g2/*.*")))

tasks = list(glob.glob("/content/gdrive/My Drive/graphs/final/*.txt"))
tasks.sort(key=lambda x: int(os.path.basename(x)[:os.path.basename(x).find('.xyz_')]))

'''
for file in tasks:
    
    #print(file)
    
    g_file = out_dir + os.path.basename(file) + "_" + str(ncolors) + "_colored"
    cnf_file = out_dir + os.path.basename(file) + "_" + str(ncolors) + "_cnf"  
    
    g = Utils.read_dimacs_graph(file)
    g2 = Utils.read_dimacs_graph('/content/gdrive/My Drive/graphs/final_d1/' + 
                                os.path.basename(file)[:os.path.basename(file).find('.xyz_')+5] + 'd1_our.txt')
    
    problem = do_coloring(g, g2, ncolors)
    print(os.path.basename(file) + ' ' + str(ncolors) + ' ' + str(problem.solved))    

    problem.formula.to_file(cnf_file)
    if problem.solved:
        Utils.write_dimacs_graph(g_file, problem.g) 
'''

"""# Test"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# '''
# def do_coloring(g = nx.Graph(), ncolors = 10):
#     
#     problem = ColSAT(g, ncolors)
#     
#     problem.build_cnf()
#     problem.solve_cnf()
#     
#     return problem
# 
# g = Utils.read_dimacs_graph("14.xyz_d2_our.txt")
# problem = do_coloring(g, 9)
# print(problem.solved)
# '''
#     #g_file = out_dir + file + "_" + str(ncolors) + "_colored"
#     #cnf_file = out_dir + file + "_" + str(ncolors) + "_cnf"
#     #proof_file = out_dir + file + "_" + str(ncolors) + "_proof"
#     
#     #problem.formula.to_file(cnf_file)
#     #if problem.solved:
#     #    Utils.write_dimacs_graph(g_file, problem.g)
#     #else:
#     #    Utils.write_proof(proof_file, problem.proof)
# 
# '''
# graph_files = ["tr_sphere_1_1_d2.txt", "tr_sphere_2_1_d2.txt", "tr_sphere_2_2_d2.txt", "tr_sphere_3_1_d2.txt", "tr_sphere_3_2_d2.txt",
#                "tr_sphere_3_3_d2.txt", "tr_sphere_4_1_d2.txt", "tr_sphere_4_2_d2.txt", "tr_sphere_4_3_d2.txt", "tr_sphere_4_4_d2.txt", 
#                "tr_sphere_5_1_d2.txt", "tr_sphere_5_2_d2.txt", "tr_sphere_5_3_d2.txt", "tr_sphere_5_4_d2.txt", "tr_sphere_5_5_d2.txt",
#                "tr_sphere_8_2_d2.txt", "tr_sphere_9_2_d2.txt"]
# 
# graph_files1 = ["tr_sphere_1_1_d2.txt", "tr_sphere_3_1_d2.txt", "tr_sphere_4_1_d2.txt", "tr_sphere_5_1_d2.txt", ]
# 
# problems7 = [(f, 7) for f in graph_files]
# problems8 = [(f, 8) for f in graph_files]
#  
# 
# def remove_nodes(g = nx.Graph(), ncolors = 7, order = []):
#     
#     n = 0
#     g2 = g.copy()
#     
#     for node in order:
#         g2 = g.copy()
#         g.remove_node(node)
#         problem = do_coloring(g, ncolors)
#         
#         if problem.solved:
#             break
#             
#         n += 1
#     
#     return (problem, g2, node, n)
#         
# def remove_edges(g = nx.Graph(), ncolors = 7, order = []):
#     
#     n = 0
#     g2 = g.copy()
#     
#     for a, b in order:
#         g2 = g.copy()
#         g.remove_edge(a, b)
#         problem = do_coloring(g, ncolors)
#         
#         if problem.solved:
#             break
#             
#         n += 1
#         
#     return (problem, g2, a, b, n)
# 
# #g2 = nx.Graph()    
# 
# for file, ncolors in problems7:
#     
#     g = Utils.read_dimacs_graph(out_dir + file)
#     
#     m = nx.convert_matrix.to_numpy_matrix(g)
#     w, v = LA.eig(m)
#     print(1 - np.max(w) / np.min(w))
# 
#     continue
#     
#     can_delete = True
#     
#     n = 0
#     while can_delete:
#         
#         ee = list(g.edges())
#         
#         can_delete = False
#         for a, b in ee:
#         
#             g2 = g.copy()
#             g2.remove_edge(a, b)
#             problem = do_coloring(g2, ncolors)
#         
#             if not problem.solved:
#                 can_delete = True
#                 n += 1
#                 g = g2.copy()
#                 print(n)
#                 break                
# '''    
# '''    
#     nnmax = 0
#     for i in range(1000):
# 
#         g = Utils.read_dimacs_graph(out_dir + file)
#         
#         nn = list(g.nodes())
#         random.shuffle(nn)  
#         
#         r = remove_nodes(g, 7, nn) #(problem, g2, node, n)
#             
#         if r[3] > nnmax:
#             #Utils.write_dimacs_graph(out_dir + file + "_smallestnn.txt", r[1], comments = ["last " + str(r[2]), "removed " + str(r[3])])
#             #Utils.write_dimacs_graph(out_dir + file + "_smalleste333 .txt", problem.g, comments = [str(a), str(b), str(n)])
#             nnmax = r[3]
#             print(file + " n " + str(nnmax))
#             
#             nemax = 0
#             for j in range(1000):
# 
#                 gg = r[1].copy()
# 
#                 ee = list(gg.edges())
#                 random.shuffle(ee)
# 
#                 r2 = remove_edges(gg, 7, ee)
# 
#                 if r2[4] > nemax:
#                     nemax = r2[4]
#                     print(" " + file + " e " + str(nemax))
#                     Utils.write_dimacs_graph(out_dir + file + "_rne_" + str(nnmax) + "_"  + str(nemax), r2[1], comments = ["lastn " + str(r[2]), 
#                                                                                             "removedn " + str(r[3]), 
#                                                                                             "laste " + str(r2[2]) + " " + str(r2[3]), 
#                                                                                             "removede " + str(r2[4])])
#             
# '''            
# 
#     #g_file = out_dir + file + "_" + str(ncolors) + "_colored"
#     #cnf_file = out_dir + file + "_" + str(ncolors) + "_cnf"
#     #proof_file = out_dir + file + "_" + str(ncolors) + "_proof"
#     
#     #problem.formula.to_file(cnf_file)
#     #if problem.solved:
#     #    Utils.write_dimacs_graph(g_file, problem.g)
#     #else:
#     #    Utils.write_proof(proof_file, problem.proof)
# 
# #problem.g.remove_nodes_from(find_isolates(problem.g))